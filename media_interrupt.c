#include "nios2_ctrl_reg_macros.h"
#include "globals.h"

#define RIGHT 1
#define LEFT 2
#define UP 4
#define DOWN 8
#define SCREEN_WIDTH 319
#define SCREEN_HEIGHT 239

/* these globals are written by interrupt service routines; we have to declare 
 * these as volatile to avoid the compiler caching their values in registers */
extern volatile char byte1, byte2, byte3;			/* modified by PS/2 interrupt service routine */
extern volatile int record, play, buffer_index;	// used for audio
extern volatile int timeout;							// used to synchronize with the timer
extern volatile int mouseDataReady;
extern volatile int mouseDataProcessing;
extern volatile struct mouse_dev mouse;

int mouseX,
    mouseY,
    lastMouseX = SCREEN_WIDTH/2,
    lastMouseY = SCREEN_HEIGHT/2;

const int box_len = 8;

/* function prototypes */
void VGA_box (int, int, int, short);
void VGA_mouse (int, int);
void fill_screen (int, int, int, int, short);
int init_ps2(void);

/********************************************************************************
 * This program demonstrates use of the media ports in the DE1 Media Computer
 *
 * It performs the following: 
 *  	1. records audio for about 10 seconds when an interrupt is generated by
 *  	   pressing KEY[1]. LEDG[0] is lit while recording. Audio recording is 
 *  	   controlled by using interrupts
 * 	2. plays the recorded audio when an interrupt is generated by pressing
 * 	   KEY[2]. LEDG[1] is lit while playing. Audio playback is controlled by 
 * 	   using interrupts
 * 	3. Draws a blue box on the VGA display, and places a text string inside
 * 	   the box. Also, moves the word ALTERA around the display, "bouncing" off
 * 	   the blue box and screen edges
 * 	4. Displays the last two bytes of data received from the PS/2 port 
 * 	   on the HEX displays on the DE1 board. The PS/2 port is handled using 
 * 	   interrupts
 * 	5. The speed of refreshing the VGA screen
 * 	   are controlled by interrupts from the interval timer
 ********************************************************************************/


int main(void)
{
  /* Declare volatile pointers to I/O registers (volatile means that IO load
     and store instructions will be used to access these pointer locations, 
     instead of regular memory loads and stores) */
  volatile int * interval_timer_ptr = (int *) 0x10002000;	// interal timer base address
  volatile int * KEY_ptr = (int *) 0x10000050;					// pushbutton KEY address
  volatile int * audio_ptr = (int *) 0x10003040;				// audio port address
  volatile int * PS2_ptr = (int *) 0x10000100;					// PS/2 port address
  unsigned int flags = 0;


  /* initialize some variables */
  byte1 = 0; byte2 = 0; 			// used to hold PS/2 data
  record = 0; play = 0; buffer_index = 0;	// used for audio record/playback
  timeout = 0;										// synchronize with the timer

  /* these variables are used for a blue box and a "bouncing" ALTERA on the VGA screen */
  int ALT_x1; int ALT_x2; int ALT_y; 
  int ALT_inc_x; int ALT_inc_y;
  int blue_x; int blue_y; 
  int screen_x; int screen_y; int char_buffer_x; int char_buffer_y;
  short color;
  const short background_color = 0x1863;

  /* set the interval timer period for scrolling the HEX displays */
  int counter = 0x960000;				// 1/(50 MHz) x (0x960000) ~= 200 msec
  *(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
  *(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

  /* start interval timer, enable its interrupts */
  *(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1 

  *(KEY_ptr + 2) = 0xE; 			/* write to the pushbutton interrupt mask register, and
  * set 3 mask bits to 1 (bit 0 is Nios II reset) */
  if(init_ps2() < 0) {
    printf("PS/2 did not init properly!\n");
  }

  NIOS2_WRITE_IENABLE( 0xC3 );	/* set interrupt mask bits for levels 0 (interval
                                 * timer), 1 (pushbuttons), 6 (audio), and 7 (PS/2) */

  NIOS2_WRITE_STATUS( 1 );		// enable Nios II interrupts

  /* create a messages to be displayed on the VGA display */
  char text_top_VGA[20] = "Altera DE1\0";
  char text_bottom_VGA[20] = "Media Computer\0";
  char text_ALTERA[10] = "Altera\0";
  char text_erase[10] = "      \0";


  /* the following variables give the size of the pixel buffer */
  screen_x = SCREEN_WIDTH; screen_y = SCREEN_HEIGHT;
  color = 0x1863;		// a dark grey color
  fill_screen (0, 0, screen_x, screen_y, color);	// fill the screen with grey
  // draw a medium-blue box around the above text, based on the character buffer coordinates
  blue_x = 28; blue_y = 26;
  // character coords * 4 since characters are 4 x 4 pixel buffer coords (8 x 8 VGA coords)
  color = 0x187F;		// a medium blue color

  char_buffer_x = 79; char_buffer_y = 59;
  ALT_x1 = 0; ALT_x2 = 5/* ALTERA = 6 chars */; ALT_y = 0; ALT_inc_x = 0; ALT_inc_y = -4;
  flags = UP;
  while (1)
  {
    while (!timeout)
      ;	// wait to synchronize with timer 

    VGA_box (blue_x, blue_y, box_len,0x1863);
    blue_x += ALT_inc_x;
    blue_y += ALT_inc_y;

    if (blue_y <= 0) {
      ALT_inc_y = -(ALT_inc_y);
      flags = DOWN;
    }
    else if (blue_x <= 0) {
      ALT_inc_x = -(ALT_inc_x);
      flags = RIGHT;
    }
    else if (blue_y+box_len >= screen_y) {
      if(blue_y+box_len > screen_y)
      {
        blue_y = screen_y-box_len-1;
      }
      if(flags & DOWN) {
        ALT_inc_y = 0;
        ALT_inc_x = -4;
        flags = LEFT;
      }
    }
    else if(blue_x+box_len >= screen_x) {
      if(blue_x > screen_x)
      {
        blue_x = screen_x-box_len-1;
      }
      if(flags & RIGHT) {
        ALT_inc_y = -4;
        ALT_inc_x = 0;
        flags = UP;
      }
    }


    /* display PS/2 data (from interrupt service routine) on HEX displays */
    // Check for sign and account for it
    mouseDataProcessing = 1;

    // Normalize the mouse input and scale into screen size
    float changeX = (((float)mouse.deltaX)/(256.0f))*SCREEN_WIDTH;
    float changeY = (-1)*((((float)mouse.deltaY)/(256.0f))*SCREEN_HEIGHT);

    // Update mouse location
    mouseX = lastMouseX + (int)changeX;
    mouseY = lastMouseY + (int)changeY;

    // Draw mouse on screen
    if(mouseDataReady) {
        fill_screen (0, 0, screen_x, screen_y, 0x1863);	// fill the screen with grey
        VGA_mouse(mouseX, mouseY);
    }
    
    VGA_box (blue_x, blue_y, box_len,color);
    mouseDataProcessing = 0;

    // Store last mouse location
    lastMouseX = mouseX;
    lastMouseY = mouseY;
    mouseDataReady = 0;
    timeout = 0;
  }
}

/****************************************************************************************
 * Draw a filled rectangle on the VGA monitor 
 ****************************************************************************************/
void VGA_box(int x, int y, int len, short pixel_color)
{
  int offset, row, col;
  volatile short * pixel_buffer = (short *) 0x08000000;	// VGA pixel buffer

  /* assume that the box coordinates are valid */
  for (row = y; row <= y+len; row++)
  {
    col = x;
    while (col <= x+len)
    {
      offset = (row << 9) + col;
      *(pixel_buffer + offset) = pixel_color;	// compute halfword address, set pixel
      ++col;
    }
  }
}

void VGA_mouse (int x, int y) {
  int offset, row, col;
  if(y < 0) {
    y=0;
    lastMouseY =0;
  }
  if(x < 0) {
    x=0;
    lastMouseX =0;
  }
  if(x > SCREEN_WIDTH-8) {
    x = SCREEN_WIDTH-8;
    lastMouseX = SCREEN_WIDTH-8;
  }
  if(y > SCREEN_HEIGHT-8) {
    y = SCREEN_HEIGHT -8;
    lastMouseY = SCREEN_HEIGHT -8;
  }
  //y = y%SCREEN_HEIGHT;
  //x = x%SCREEN_WIDTH;
  volatile short * pixel_buffer = (short *) 0x08000000;	// VGA pixel buffer
  const int len = 7;
  short pixelColor;
  const short allUp = 0xFFFF,
        leftDown = 0xF00F,
        rightDown = 0xFFFF,
        bothDown = 0xFFFF;
  //logic to determine how much to move the box
  if(mouse.buttons & LMB) {
    pixelColor = leftDown;
  }
  else if(mouse.buttons & RMB) {
    pixelColor = rightDown;
  }
  else {
    pixelColor = allUp;
  }
  /* assume that the box coordinates are valid */
  VGA_box(x, y, len, pixelColor);
}

/****************************************************************************************
 * Draw a filled rectangle on the VGA monitor 
 ****************************************************************************************/
void fill_screen(int x1, int y1, int x2, int y2, short pixel_color)
{
  int offset, row, col;
  volatile short * pixel_buffer = (short *) 0x08000000;	// VGA pixel buffer

  /* assume that the box coordinates are valid */
  for (row = y1; row <= y2; row++)
  {
    col = x1;
    while (col <= x2)
    {
      offset = (row << 9) + col;
      *(pixel_buffer + offset) = pixel_color;	// compute halfword address, set pixel
      ++col;
    }
  }
}

int init_ps2(void)
{
    volatile int * PS2_ptr = (int *) 0x10000100;		// PS/2 port address
    char PS2_data;
    // Reset the mouse
    *(PS2_ptr) = 0xFF;

    // Write to the PS/2 Control register to enable interrupts
    *(PS2_ptr + 1) = 0x1;

    PS2_data = (*PS2_ptr)&(char)0xFF;
    // Wait for an ACK
    while(PS2_data != (char)0xFA) {
        PS2_data = (*PS2_ptr)&(char)0xFF;
       // printf("waiting for ack");
    }

    // Wait for a response from the BAT. 0xAA means OK, 0xFC means error
    while(PS2_data != (char)0xAA && PS2_data != (char)0xFC) {
        PS2_data = (*PS2_ptr)&(char)0xFF;
       // printf("waiting for response from BAT and ps2 data is: %x\n", PS2_data);
    }
    if(PS2_data == (char)0xFC)
    {
        printf("data bad");
        return -1;
    }
    // Wait until the mouse ID is received
    while(*(PS2_ptr) == PS2_data) {
      //  printf("waiting for the mouseID receive");
    }
    PS2_data = (*PS2_ptr)&(char)0xFF;

    // ID == 0x03, scrollwheel mouse with 4 byte packet.
    // we do not support this
    if(PS2_data == (char)0x03) {
       // printf("scroll stuffs bad");
        return -1;
    }


    // Enable reporting of new data
    (*PS2_ptr) = 0xF4;

    // Wait for an ACK
    while(PS2_data != (char)0xFA) {
       // printf("waiting for ack again");
        PS2_data = (*PS2_ptr)&(char)0xFF;
    }


    return 0;
}
